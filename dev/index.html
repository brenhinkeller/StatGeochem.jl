<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · StatGeochem.jl</title><link rel="canonical" href="https://brenhinkeller.github.io/StatGeochem.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StatGeochem.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StatGeochem"><a class="docs-heading-anchor" href="#StatGeochem">StatGeochem</a><a id="StatGeochem-1"></a><a class="docs-heading-anchor-permalink" href="#StatGeochem" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/brenhinkeller/StatGeochem.jl">StatGeochem</a>.</p><ul><li><a href="#StatGeochem.Ayers_tsphene-NTuple{10, Any}"><code>StatGeochem.Ayers_tsphene</code></a></li><li><a href="#StatGeochem.Ayers_tspheneTiO2-NTuple{11, Any}"><code>StatGeochem.Ayers_tspheneTiO2</code></a></li><li><a href="#StatGeochem.Boehnke_tzirc-NTuple{11, Any}"><code>StatGeochem.Boehnke_tzirc</code></a></li><li><a href="#StatGeochem.Boehnke_tzircM-NTuple{10, Number}"><code>StatGeochem.Boehnke_tzircM</code></a></li><li><a href="#StatGeochem.Boehnke_tzircZr-NTuple{11, Any}"><code>StatGeochem.Boehnke_tzircZr</code></a></li><li><a href="#StatGeochem.Harrison_tapatite-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Number"><code>StatGeochem.Harrison_tapatite</code></a></li><li><a href="#StatGeochem.Harrison_tapatiteP-Tuple"><code>StatGeochem.Harrison_tapatiteP</code></a></li><li><a href="#StatGeochem.Harrison_tapatiteP2O5-Union{Tuple{T}, NTuple{6, T}} where T&lt;:Number"><code>StatGeochem.Harrison_tapatiteP2O5</code></a></li><li><a href="#StatGeochem.LREEmolwt-NTuple{6, Any}"><code>StatGeochem.LREEmolwt</code></a></li><li><a href="#StatGeochem.LREEt-Union{Tuple{T}, NTuple{6, T}} where T&lt;:Number"><code>StatGeochem.LREEt</code></a></li><li><a href="#StatGeochem.MSWD-Tuple{Any, Any}"><code>StatGeochem.MSWD</code></a></li><li><a href="#StatGeochem.Montel_tmonazite-NTuple{16, Any}"><code>StatGeochem.Montel_tmonazite</code></a></li><li><a href="#StatGeochem.Montel_tmonaziteREE-NTuple{11, Any}"><code>StatGeochem.Montel_tmonaziteREE</code></a></li><li><a href="#StatGeochem.Rusiecka_tmonaziteREE-Tuple{Any, Any}"><code>StatGeochem.Rusiecka_tmonaziteREE</code></a></li><li><a href="#StatGeochem.Rusiecka_txenotimeY-Tuple{Any, Any}"><code>StatGeochem.Rusiecka_txenotimeY</code></a></li><li><a href="#StatGeochem.Tollari_tapatite-NTuple{9, Any}"><code>StatGeochem.Tollari_tapatite</code></a></li><li><a href="#StatGeochem.Tollari_tapatiteP2O5-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>StatGeochem.Tollari_tapatiteP2O5</code></a></li><li><a href="#StatGeochem.arcdistance-NTuple{4, Any}"><code>StatGeochem.arcdistance</code></a></li><li><a href="#StatGeochem.awmean-Tuple{Any, Any}"><code>StatGeochem.awmean</code></a></li><li><a href="#StatGeochem.bin_bsr-Tuple{Function, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Integer}"><code>StatGeochem.bin_bsr</code></a></li><li><a href="#StatGeochem.bin_bsr_ratios-Tuple{Function, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Integer}"><code>StatGeochem.bin_bsr_ratios</code></a></li><li><a href="#StatGeochem.bincounts-Tuple{AbstractArray, Number, Number, Integer}"><code>StatGeochem.bincounts</code></a></li><li><a href="#StatGeochem.binmeans-Tuple{AbstractArray, AbstractArray, Number, Number, Integer}"><code>StatGeochem.binmeans</code></a></li><li><a href="#StatGeochem.binmedians-Tuple{AbstractArray, AbstractArray, Number, Number, Integer}"><code>StatGeochem.binmedians</code></a></li><li><a href="#StatGeochem.bsr!-Tuple{Function, Array, Vector{Int64}, AbstractArray, Number, Number}"><code>StatGeochem.bsr!</code></a></li><li><a href="#StatGeochem.bsresample"><code>StatGeochem.bsresample</code></a></li><li><a href="#StatGeochem.bsresample"><code>StatGeochem.bsresample</code></a></li><li><a href="#StatGeochem.changepoint-Tuple{AbstractArray, Integer}"><code>StatGeochem.changepoint</code></a></li><li><a href="#StatGeochem.cntr-Tuple{AbstractArray}"><code>StatGeochem.cntr</code></a></li><li><a href="#StatGeochem.concatenatedatasets-Tuple{AbstractDict, AbstractDict}"><code>StatGeochem.concatenatedatasets</code></a></li><li><a href="#StatGeochem.count_unique!-Tuple{Any}"><code>StatGeochem.count_unique!</code></a></li><li><a href="#StatGeochem.delim_string_function-Tuple{Function, AbstractString, Char, Type}"><code>StatGeochem.delim_string_function</code></a></li><li><a href="#StatGeochem.delim_string_parse"><code>StatGeochem.delim_string_parse</code></a></li><li><a href="#StatGeochem.delim_string_parse!"><code>StatGeochem.delim_string_parse!</code></a></li><li><a href="#StatGeochem.digitize_plotline-NTuple{4, Any}"><code>StatGeochem.digitize_plotline</code></a></li><li><a href="#StatGeochem.digitize_plotmarkers-NTuple{4, Any}"><code>StatGeochem.digitize_plotmarkers</code></a></li><li><a href="#StatGeochem.draw_from_distribution-Tuple{AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:AbstractFloat, N}, Integer}"><code>StatGeochem.draw_from_distribution</code></a></li><li><a href="#StatGeochem.draw_from_distribution!-Tuple{Array{var&quot;#s37&quot;, N} where {var&quot;#s37&quot;&lt;:AbstractFloat, N}, AbstractArray{var&quot;#s32&quot;, N} where {var&quot;#s32&quot;&lt;:AbstractFloat, N}}"><code>StatGeochem.draw_from_distribution!</code></a></li><li><a href="#StatGeochem.elementify"><code>StatGeochem.elementify</code></a></li><li><a href="#StatGeochem.eustar-NTuple{4, Number}"><code>StatGeochem.eustar</code></a></li><li><a href="#StatGeochem.eustar-Tuple{Number, Number}"><code>StatGeochem.eustar</code></a></li><li><a href="#StatGeochem.exportdataset-Tuple{Union{Dict, NamedTuple}, AbstractString, AbstractChar}"><code>StatGeochem.exportdataset</code></a></li><li><a href="#StatGeochem.feoconversion"><code>StatGeochem.feoconversion</code></a></li><li><a href="#StatGeochem.find_grid_inpolygon-NTuple{4, Any}"><code>StatGeochem.find_grid_inpolygon</code></a></li><li><a href="#StatGeochem.find_tc1_age-Tuple{Number, Number}"><code>StatGeochem.find_tc1_age</code></a></li><li><a href="#StatGeochem.find_tc1_crust-Tuple{Number, Number}"><code>StatGeochem.find_tc1_crust</code></a></li><li><a href="#StatGeochem.find_tc1_lith-Tuple{Number, Number}"><code>StatGeochem.find_tc1_lith</code></a></li><li><a href="#StatGeochem.findclosest-Tuple{Any, Any}"><code>StatGeochem.findclosest</code></a></li><li><a href="#StatGeochem.findclosestabove-Tuple{Any, Any}"><code>StatGeochem.findclosestabove</code></a></li><li><a href="#StatGeochem.findclosestbelow-Tuple{Any, Any}"><code>StatGeochem.findclosestbelow</code></a></li><li><a href="#StatGeochem.findmatches-Tuple{Any, Any}"><code>StatGeochem.findmatches</code></a></li><li><a href="#StatGeochem.findnth-Tuple{AbstractArray{Bool, N} where N, Integer}"><code>StatGeochem.findnth</code></a></li><li><a href="#StatGeochem.floatify"><code>StatGeochem.floatify</code></a></li><li><a href="#StatGeochem.gwmean-Tuple{Any, Any}"><code>StatGeochem.gwmean</code></a></li><li><a href="#StatGeochem.importdataset-Tuple{AbstractString, AbstractChar}"><code>StatGeochem.importdataset</code></a></li><li><a href="#StatGeochem.inpctile-Tuple{Any, Any}"><code>StatGeochem.inpctile</code></a></li><li><a href="#StatGeochem.inpolygon-Tuple{Any, Any, Any}"><code>StatGeochem.inpolygon</code></a></li><li><a href="#StatGeochem.inv_sqrt-Tuple{Float64}"><code>StatGeochem.inv_sqrt</code></a></li><li><a href="#StatGeochem.invweight-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>StatGeochem.invweight</code></a></li><li><a href="#StatGeochem.invweight-Tuple{AbstractArray, Number}"><code>StatGeochem.invweight</code></a></li><li><a href="#StatGeochem.invweight_age-Tuple{AbstractArray}"><code>StatGeochem.invweight_age</code></a></li><li><a href="#StatGeochem.invweight_location-Tuple{AbstractArray, AbstractArray}"><code>StatGeochem.invweight_location</code></a></li><li><a href="#StatGeochem.melts_clean_modes-Tuple{String}"><code>StatGeochem.melts_clean_modes</code></a></li><li><a href="#StatGeochem.melts_configure"><code>StatGeochem.melts_configure</code></a></li><li><a href="#StatGeochem.melts_query-Tuple{String}"><code>StatGeochem.melts_query</code></a></li><li><a href="#StatGeochem.melts_query_liquid-Tuple{String}"><code>StatGeochem.melts_query_liquid</code></a></li><li><a href="#StatGeochem.melts_query_modes-Tuple{String}"><code>StatGeochem.melts_query_modes</code></a></li><li><a href="#StatGeochem.melts_query_solid-Tuple{String}"><code>StatGeochem.melts_query_solid</code></a></li><li><a href="#StatGeochem.midpointintegrate-Tuple{AbstractRange, AbstractArray}"><code>StatGeochem.midpointintegrate</code></a></li><li><a href="#StatGeochem.movmean-Tuple{AbstractVector{T} where T, Number}"><code>StatGeochem.movmean</code></a></li><li><a href="#StatGeochem.nanaad-Tuple{Any}"><code>StatGeochem.nanaad</code></a></li><li><a href="#StatGeochem.nanadd-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}"><code>StatGeochem.nanadd</code></a></li><li><a href="#StatGeochem.nanadd-Tuple{Any, Any}"><code>StatGeochem.nanadd</code></a></li><li><a href="#StatGeochem.nanadd!-Tuple{Array, Union{Tuple, AbstractArray}}"><code>StatGeochem.nanadd!</code></a></li><li><a href="#StatGeochem.nanextrema-Tuple{Any}"><code>StatGeochem.nanextrema</code></a></li><li><a href="#StatGeochem.nanmad-Tuple{Any}"><code>StatGeochem.nanmad</code></a></li><li><a href="#StatGeochem.nanmask-Tuple{Any}"><code>StatGeochem.nanmask</code></a></li><li><a href="#StatGeochem.nanmask!-Tuple{Any, Any}"><code>StatGeochem.nanmask!</code></a></li><li><a href="#StatGeochem.nanmax-Tuple{Any, Any}"><code>StatGeochem.nanmax</code></a></li><li><a href="#StatGeochem.nanmaximum-Tuple{Any}"><code>StatGeochem.nanmaximum</code></a></li><li><a href="#StatGeochem.nanmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmean</code></a></li><li><a href="#StatGeochem.nanmean-Tuple{Any}"><code>StatGeochem.nanmean</code></a></li><li><a href="#StatGeochem.nanmean!-Tuple{AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmean!</code></a></li><li><a href="#StatGeochem.nanmedian-Tuple{Any}"><code>StatGeochem.nanmedian</code></a></li><li><a href="#StatGeochem.nanmedian-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmedian</code></a></li><li><a href="#StatGeochem.nanmedian!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmedian!</code></a></li><li><a href="#StatGeochem.nanmin-Tuple{Any, Any}"><code>StatGeochem.nanmin</code></a></li><li><a href="#StatGeochem.nanminimum-Tuple{Any}"><code>StatGeochem.nanminimum</code></a></li><li><a href="#StatGeochem.nanrange-Tuple{Any}"><code>StatGeochem.nanrange</code></a></li><li><a href="#StatGeochem.nanstd-Tuple{Any}"><code>StatGeochem.nanstd</code></a></li><li><a href="#StatGeochem.nansum-Tuple{Any}"><code>StatGeochem.nansum</code></a></li><li><a href="#StatGeochem.nearest-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Integer"><code>StatGeochem.nearest</code></a></li><li><a href="#StatGeochem.nonnumeric-Tuple{Any}"><code>StatGeochem.nonnumeric</code></a></li><li><a href="#StatGeochem.norm_quantile-Tuple{Any}"><code>StatGeochem.norm_quantile</code></a></li><li><a href="#StatGeochem.norm_width-Tuple{Any}"><code>StatGeochem.norm_width</code></a></li><li><a href="#StatGeochem.normcdf-Tuple{Any, Any, Any}"><code>StatGeochem.normcdf</code></a></li><li><a href="#StatGeochem.normcdf!-Tuple{Array, Number, Number, AbstractArray}"><code>StatGeochem.normcdf!</code></a></li><li><a href="#StatGeochem.normpdf-Tuple{Any, Any, Any}"><code>StatGeochem.normpdf</code></a></li><li><a href="#StatGeochem.normpdf_ll-Tuple{Any, Any, Any}"><code>StatGeochem.normpdf_ll</code></a></li><li><a href="#StatGeochem.normproduct-NTuple{4, Any}"><code>StatGeochem.normproduct</code></a></li><li><a href="#StatGeochem.normproduct_ll-NTuple{4, Any}"><code>StatGeochem.normproduct_ll</code></a></li><li><a href="#StatGeochem.oxideconversion-Tuple{Dict}"><code>StatGeochem.oxideconversion</code></a></li><li><a href="#StatGeochem.oxideconversion!-Tuple{Dict}"><code>StatGeochem.oxideconversion!</code></a></li><li><a href="#StatGeochem.parsedlm"><code>StatGeochem.parsedlm</code></a></li><li><a href="#StatGeochem.pctile-Tuple{Any, Any}"><code>StatGeochem.pctile</code></a></li><li><a href="#StatGeochem.perplex_configure_geotherm"><code>StatGeochem.perplex_configure_geotherm</code></a></li><li><a href="#StatGeochem.perplex_configure_isobar"><code>StatGeochem.perplex_configure_isobar</code></a></li><li><a href="#StatGeochem.perplex_configure_pseudosection"><code>StatGeochem.perplex_configure_pseudosection</code></a></li><li><a href="#StatGeochem.perplex_query_modes-Tuple{String, String}"><code>StatGeochem.perplex_query_modes</code></a></li><li><a href="#StatGeochem.perplex_query_modes-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_modes</code></a></li><li><a href="#StatGeochem.perplex_query_phase-Tuple{String, String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_phase</code></a></li><li><a href="#StatGeochem.perplex_query_phase-Tuple{String, String, String}"><code>StatGeochem.perplex_query_phase</code></a></li><li><a href="#StatGeochem.perplex_query_point-Tuple{String, String, Number}"><code>StatGeochem.perplex_query_point</code></a></li><li><a href="#StatGeochem.perplex_query_point-Tuple{String, String, Number, Number}"><code>StatGeochem.perplex_query_point</code></a></li><li><a href="#StatGeochem.perplex_query_seismic-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_seismic</code></a></li><li><a href="#StatGeochem.perplex_query_seismic-Tuple{String, String}"><code>StatGeochem.perplex_query_seismic</code></a></li><li><a href="#StatGeochem.perplex_query_system-Tuple{String, String}"><code>StatGeochem.perplex_query_system</code></a></li><li><a href="#StatGeochem.perplex_query_system-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_system</code></a></li><li><a href="#StatGeochem.plausiblynumeric-Tuple{Any}"><code>StatGeochem.plausiblynumeric</code></a></li><li><a href="#StatGeochem.randsample"><code>StatGeochem.randsample</code></a></li><li><a href="#StatGeochem.randsample"><code>StatGeochem.randsample</code></a></li><li><a href="#StatGeochem.renormalize!"><code>StatGeochem.renormalize!</code></a></li><li><a href="#StatGeochem.renormalize!-Tuple{AbstractArray}"><code>StatGeochem.renormalize!</code></a></li><li><a href="#StatGeochem.standardize-Tuple{AbstractArray}"><code>StatGeochem.standardize</code></a></li><li><a href="#StatGeochem.standardize!-Tuple{Array{var&quot;#s32&quot;, N} where {var&quot;#s32&quot;&lt;:AbstractFloat, N}}"><code>StatGeochem.standardize!</code></a></li><li><a href="#StatGeochem.system-Tuple{AbstractString}"><code>StatGeochem.system</code></a></li><li><a href="#StatGeochem.trapz-Tuple{AbstractRange, AbstractArray}"><code>StatGeochem.trapz</code></a></li><li><a href="#StatGeochem.unelementify"><code>StatGeochem.unelementify</code></a></li><li><a href="#StatGeochem.yorkfit-NTuple{4, Any}"><code>StatGeochem.yorkfit</code></a></li><li><a href="#StatGeochem.zeronan!-Tuple{Array}"><code>StatGeochem.zeronan!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Ayers_tsphene-NTuple{10, Any}" href="#StatGeochem.Ayers_tsphene-NTuple{10, Any}"><code>StatGeochem.Ayers_tsphene</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TC = Ayers_tsphene(SiO2, TiO2, Al2O3, FeOT, MnO, MgO, CaO, Na2O, K2O, P2O5)</code></pre><p>Calculate sphene saturation temperature in degrees Celsius Following the sphene saturation calibration of Ayers et al., 2018 (doi: 10.1130/abs/2018AM-320568)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1638-L1645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Ayers_tspheneTiO2-NTuple{11, Any}" href="#StatGeochem.Ayers_tspheneTiO2-NTuple{11, Any}"><code>StatGeochem.Ayers_tspheneTiO2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TiO2Sat = Ayers_tspheneTiO2(SiO2, TiO2, Al2O3, FeOT, MnO, MgO, CaO, Na2O, K2O, P2O5, T)</code></pre><p>Calculate sphene saturation TiO2 concentration (in wt. %) for a given temperature (in C) following the sphene saturation calibration of Ayers et al., 2018 (doi: 10.1130/abs/2018AM-320568)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1622-L1629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Boehnke_tzirc-NTuple{11, Any}" href="#StatGeochem.Boehnke_tzirc-NTuple{11, Any}"><code>StatGeochem.Boehnke_tzirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T = Boehnke_tzirc(SiO2, TiO2, Al2O3, FeOT, MnO, MgO, CaO, Na2O, K2O, P2O5, Zr)</code></pre><p>Calculate zircon saturation temperature in degrees Celsius Following the zircon saturation calibration of Boehnke, Watson, et al., 2013 (doi: 10.1016/j.chemgeo.2013.05.028)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1578-L1585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Boehnke_tzircM-NTuple{10, Number}" href="#StatGeochem.Boehnke_tzircM-NTuple{10, Number}"><code>StatGeochem.Boehnke_tzircM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">M = Boehnke_tzircM(SiO2, TiO2, Al2O3, FeOT, MnO, MgO, CaO, Na2O, K2O, P2O5)</code></pre><p>Calculate zircon saturation M-value based on major element concentrations Following the zircon saturation calibration of Boehnke, Watson, et al., 2013 (doi: 10.1016/j.chemgeo.2013.05.028)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1500-L1507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Boehnke_tzircZr-NTuple{11, Any}" href="#StatGeochem.Boehnke_tzircZr-NTuple{11, Any}"><code>StatGeochem.Boehnke_tzircZr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ZrSat = Boehnke_tzircZr(SiO2, TiO2, Al2O3, FeOT, MnO, MgO, CaO, Na2O, K2O, P2O5, T)</code></pre><p>Calculate zircon saturation Zr concentration for a given temperature (in C) Following the zircon saturation calibration of Boehnke, Watson, et al., 2013 (doi: 10.1016/j.chemgeo.2013.05.028)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1560-L1567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Harrison_tapatite-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Number" href="#StatGeochem.Harrison_tapatite-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Number"><code>StatGeochem.Harrison_tapatite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TC = Harrison_tapatite(SiO2, P2O5)</code></pre><p>Calculate apatite saturation temperature in degrees Celcius following the apatite saturation model of Harrison and Watson 1984 (doi: 10.1016/0016-7037(84)90403-4)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1810-L1817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Harrison_tapatiteP-Tuple" href="#StatGeochem.Harrison_tapatiteP-Tuple"><code>StatGeochem.Harrison_tapatiteP</code></a> — <span class="docstring-category">Method</span></header><section><div><p>As <code>Harrison_tapatiteP2O5</code>, but returns saturation phosphorus concentration in PPM P</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1804-L1806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Harrison_tapatiteP2O5-Union{Tuple{T}, NTuple{6, T}} where T&lt;:Number" href="#StatGeochem.Harrison_tapatiteP2O5-Union{Tuple{T}, NTuple{6, T}} where T&lt;:Number"><code>StatGeochem.Harrison_tapatiteP2O5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">P2O5 = Harrison_tapatiteP2O5(SiO2, Al2O3, CaO, Na2O, K2O, T)</code></pre><p>Calculate <code>P2O5</code> concentration (in wt.%) required for apatite saturation at a given <code>T</code> (in C) following the apatite saturation model of Harrison and Watson 1984 (doi: 10.1016/0016-7037(84)90403-4) with the correction of Bea et al. 1992 (doi: 10.1016/0024-4937(92)90033-U) where applicable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1782-L1790">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.LREEmolwt-NTuple{6, Any}" href="#StatGeochem.LREEmolwt-NTuple{6, Any}"><code>StatGeochem.LREEmolwt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LREEmolwt(La, Ce, Pr, Nd, Sm, Gd)</code></pre><p>Returns the average molecular weight of the LREE considered in the REEt value from the monazite saturation model of Montel 1993 (doi: 10.1016/0009-2541(93)90250-M)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1654-L1661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.LREEt-Union{Tuple{T}, NTuple{6, T}} where T&lt;:Number" href="#StatGeochem.LREEt-Union{Tuple{T}, NTuple{6, T}} where T&lt;:Number"><code>StatGeochem.LREEt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LREEt(La, Ce, Pr, Nd, Sm, Gd)</code></pre><p>Returns the sum of the LREE concentrations divided by their respective molar masses. If REE are input in parts per million by weight (ppmw), the result is in units of moles per megagram. This is equivalent to the REEt value from the monazite saturation model of Montel 1993 (doi: 10.1016/0009-2541(93)90250-M)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1667-L1675">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.MSWD-Tuple{Any, Any}" href="#StatGeochem.MSWD-Tuple{Any, Any}"><code>StatGeochem.MSWD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MSWD(x, σ)</code></pre><p>Return the Mean Square of Weighted Deviates (AKA the reduced chi-squared statistic) of a dataset with values <code>x</code> and one-sigma uncertainties <code>σ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L404-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Montel_tmonazite-NTuple{16, Any}" href="#StatGeochem.Montel_tmonazite-NTuple{16, Any}"><code>StatGeochem.Montel_tmonazite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TC = Montel_tmonazite(SiO2, TiO2, Al2O3, FeOT, MgO, CaO, Na2O, K2O, Li2O, H2O, La, Ce, Pr, Nd, Sm, Gd)</code></pre><p>Calculate monazite saturation temperature in degrees Celcius following the monazite saturation model of Montel 1993 (doi: 10.1016/0009-2541(93)90250-M)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1733-L1740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Montel_tmonaziteREE-NTuple{11, Any}" href="#StatGeochem.Montel_tmonaziteREE-NTuple{11, Any}"><code>StatGeochem.Montel_tmonaziteREE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">REEt = Montel_tmonaziteREE(SiO2, TiO2, Al2O3, FeOT, MgO, CaO, Na2O, K2O, Li2O, H2O, T)</code></pre><p>Calculate monazite saturation REEt value (in [ppm/mol.wt.]) for a given temperature (in C) following the monazite saturation model of Montel 1993 (doi: 10.1016/0009-2541(93)90250-M), where:</p><p>D = (Na + K + Li + 2Ca) / Al * 1/(Al + Si)) # all as molar cation fractions (not at. %!) ln(REEt) = 9.50 + 2.34D + 0.3879√H2O - 13318/T # H2O as wt.% REEt = Σ REEᵢ(ppm) / at. weight (g/mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1714-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Rusiecka_tmonaziteREE-Tuple{Any, Any}" href="#StatGeochem.Rusiecka_tmonaziteREE-Tuple{Any, Any}"><code>StatGeochem.Rusiecka_tmonaziteREE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LREEt = Rusiecka_tmonaziteREE(P_ppm, TC)</code></pre><p>Calculate the LREEt (mol/Megagram) value required for monazite saturation at a temperature of <code>TC</code> degrees celcius and <code>P</code> ppmw phosphorous present, following the solubility model of Rusiecka &amp; Baker, 2019 (doi: 10.2138/am-2019-6931)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1750-L1758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Rusiecka_txenotimeY-Tuple{Any, Any}" href="#StatGeochem.Rusiecka_txenotimeY-Tuple{Any, Any}"><code>StatGeochem.Rusiecka_txenotimeY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">LREEt = Rusiecka_txenotimeY(P_ppm, TC)</code></pre><p>Calculate the Y (ppmw) concentration required for xenotime saturation at a temperature of <code>TC</code> degrees celcius and <code>P</code> ppmw phosphorous present, following the solubility model of Rusiecka &amp; Baker, 2019 (doi: 10.2138/am-2019-6931)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1766-L1774">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Tollari_tapatite-NTuple{9, Any}" href="#StatGeochem.Tollari_tapatite-NTuple{9, Any}"><code>StatGeochem.Tollari_tapatite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TC = Tollari_tapatite(SiO2, TiO2, Al2O3, FeOT, MgO, CaO, Na2O, K2O, P2O5)</code></pre><p>Calculate apatite saturation temperature in degrees Celcius following the apatite saturation model of Tollari et al. 2006 (doi: 10.1016/j.gca.2005.11.024)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1841-L1848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.Tollari_tapatiteP2O5-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number" href="#StatGeochem.Tollari_tapatiteP2O5-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Number"><code>StatGeochem.Tollari_tapatiteP2O5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">P2O5 = Tollari_tapatiteP2O5(SiO2, CaO, T)</code></pre><p>Calculate <code>P2O5</code> concentration (in wt.%) required for apatite saturation at a given <code>T</code> (in C) following the apatite saturation model of Tollari et al. 2006 (doi: 10.1016/j.gca.2005.11.024)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1824-L1831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.arcdistance-NTuple{4, Any}" href="#StatGeochem.arcdistance-NTuple{4, Any}"><code>StatGeochem.arcdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arcdistance(latᵢ,lonᵢ,lat,lon)</code></pre><p>Calculate the distance on a sphere between the point (<code>latᵢ</code>,<code>lonᵢ</code>) and any number of points in (<code>lat</code>,<code>lon</code>). Latitude and Longitude should be specified in decimal degrees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L329-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.awmean-Tuple{Any, Any}" href="#StatGeochem.awmean-Tuple{Any, Any}"><code>StatGeochem.awmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(wx, wσ, mswd) = awmean(x, σ)</code></pre><p>Weighted mean, absent the geochonologist&#39;s MSWD correction to uncertainty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.bin_bsr-Tuple{Function, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Integer}" href="#StatGeochem.bin_bsr-Tuple{Function, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Integer}"><code>StatGeochem.bin_bsr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bin_bsr([f!::Function], x::Vector, y::VecOrMat, xmin, xmax, nbins, [w];
    	x_sigma = zeros(size(x)),
    	y_sigma = zeros(size(y)),
    	nresamplings = 1000,
    	sem = :sigma,
    	p = 0.2
)</code></pre><p>Returns the bincenters <code>c</code>, means or medians <code>m</code>, and uncertainties of the mean or median for a variable <code>y</code> binned by independent variable <code>x</code> into <code>nbins</code> equal bins between <code>xmin</code> and <code>xmax</code>, after <code>nresamplings</code> boostrap resamplings with acceptance probability <code>p</code>.</p><p>If a 2-d array (matrix) of <code>y</code> values is provided, each column will be treated as a separate variable, means and uncertainties will be returned column-wise.</p><p>Optional keyword arguments and defaults:</p><pre><code class="language-none">x_sigma = zeros(size(x))</code></pre><p>A vector representing the uncertainty (standard deviation) of each x value</p><pre><code class="language-none">y_sigma = zeros(size(y))</code></pre><p>A vector representing the uncertainty (standard deviation) of each y value</p><pre><code class="language-none">nresamplings = 1000</code></pre><p>The number of resamplings to conduct</p><pre><code class="language-none">sem = :sigma</code></pre><p>Format of the uncertainty estimate of the distribution of the mean. If <code>:sigma</code> is chosen, a tuple of three vectors <code>(c, m, e)</code> will be returned, where <code>e</code> is the standard error of the mean. If <code>:CI</code> or <code>:pctile</code> is chosen, a tuple of four vectors <code>(c, m, el, eu)</code> will be returned, where <code>el</code> and <code>eu</code> are the lower and upper bounds of the 95% confidence interval.</p><pre><code class="language-none">p = 0.2</code></pre><p>Resampling probabilities, either as a scalar or a vector of the same length as <code>x</code></p><p><strong>Examples:</strong></p><pre><code class="language-julia">(c,m,e) = bin_bsr(nanmedian!, x, y, 0, 4000, 40, x_sigma=0.05x, p=probability, sem=:sigma)</code></pre><pre><code class="language-julia">(c,m,el,eu) = bin_bsr(nanmean!, x, y, 0, 4000, 40, x_sigma=0.05x, p=probability, sem=:pctile)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L460-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.bin_bsr_ratios-Tuple{Function, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Integer}" href="#StatGeochem.bin_bsr_ratios-Tuple{Function, AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Any, Any, Integer}"><code>StatGeochem.bin_bsr_ratios</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(c, m, el, eu) = bin_bsr_ratios([f!::Function], x::Vector, num::Vector, denom::Vector, xmin, xmax, nbins, [w];
    	x_sigma = zeros(size(x)),
    	num_sigma = zeros(size(num)),
    	denom_sigma = zeros(size(denom)),
    	nresamplings = 1000,
    	p::Union{Number,Vector} = 0.2
)</code></pre><p>Returns the bincenters <code>c</code>, means <code>m</code>, as well as upper (<code>el</code>) and lower (<code>eu</code>) 95% CIs of the mean for a ratio <code>num</code>/<code>den</code> binned by <code>x</code> into <code>nbins</code> equal bins between <code>xmin</code> and <code>xmax</code>, after <code>nresamplings</code> boostrap resamplings with acceptance probability <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L670-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.bincounts-Tuple{AbstractArray, Number, Number, Integer}" href="#StatGeochem.bincounts-Tuple{AbstractArray, Number, Number, Integer}"><code>StatGeochem.bincounts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(bincenters, N) = bincounts(x::AbstractArray, xmin::Number, xmax::Number, nbins::Integer)</code></pre><p>Tally the number of samples that fall into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, aligned with bin edges as <code>xmin:(xmax-xmin)/nbins:xmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L339-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.binmeans-Tuple{AbstractArray, AbstractArray, Number, Number, Integer}" href="#StatGeochem.binmeans-Tuple{AbstractArray, AbstractArray, Number, Number, Integer}"><code>StatGeochem.binmeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(c,m,e) = binmeans(x, y, xmin, xmax, nbins, [weight]; resamplingratio::Number=1)</code></pre><p>The means (ignoring NaNs) of <code>y</code> values binned by <code>x</code>, into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, returning bincenters, means, and standard errors of the mean.</p><p>To calculate binned medians only (without uncertainties), see <code>nanmean</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L367-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.binmedians-Tuple{AbstractArray, AbstractArray, Number, Number, Integer}" href="#StatGeochem.binmedians-Tuple{AbstractArray, AbstractArray, Number, Number, Integer}"><code>StatGeochem.binmedians</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(c,m,e) = binmedians(x, y, xmin, xmax, nbins; resamplingratio::Number=1)</code></pre><p>The medians (ignoring NaNs) of <code>y</code> values binned by <code>x</code>, into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, returning bincenters, medians, and equivalent standard errors of the mean (1.4828 * median abolute deviation)</p><p>To calculate binned medians only (without uncertainties), see <code>nanmedian</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L430-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.bsr!-Tuple{Function, Array, Vector{Int64}, AbstractArray, Number, Number}" href="#StatGeochem.bsr!-Tuple{Function, Array, Vector{Int64}, AbstractArray, Number, Number}"><code>StatGeochem.bsr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bsr!([f::Function], resampled::Array, index::Vector{Int}, data, sigma, p;
    	rng::AbstractRNG=MersenneTwister()
)</code></pre><p>Fill <code>resampled</code> with data boostrap resampled from a (sample-per-row / element-per-column) dataset <code>data</code> with uncertainties <code>sigma</code> and resampling probabilities <code>p</code>, optionally using random numbers generated by <code>f</code> where <code>f</code> is a function of the form <code>f(rng, data[i], sigma[i])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.bsresample" href="#StatGeochem.bsresample"><code>StatGeochem.bsresample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resampled = bsresample(data::AbstractArray, sigma, nrows, [p];
    	 kernel = gaussian,
    	 rng = MersenneTwister(),
    	 return_index = false
)</code></pre><p>Bootstrap resample a (sample-per-row / element-per-column) array of <code>data</code> with uncertainties <code>sigma</code> and resampling probabilities <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.bsresample" href="#StatGeochem.bsresample"><code>StatGeochem.bsresample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resampled = bsresample(dataset::Dict, nrows, [elements], [p];
    	 kernel = gaussian,
    	 rng = MersenneTwister()
)</code></pre><p>Bootstrap resample a dictionary-based <code>dataset</code> with uncertainties stored either in <code>dataset[&quot;err&quot;]</code> or <code>dataset[&quot;[variable]_sigma&quot;]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L209-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.changepoint-Tuple{AbstractArray, Integer}" href="#StatGeochem.changepoint-Tuple{AbstractArray, Integer}"><code>StatGeochem.changepoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">changepoint(data, [sigma], nsteps; np, npmin, npmax)</code></pre><p>Given an ordered array of <code>data</code> points, optionally with uncertainties <code>sigma</code>, use a Markov chain Monte Carlo approach based on that of Gallagher et al., 2010 (10.1016/j.epsl.2011.09.015) to estimate the position (by index) and optionally number of changepoints that best explain the <code>data</code>. Will return the results for <code>nsteps</code> steps of the Markov chain.</p><p>Optionally, you may also specify as keyword arguments either <code>np</code> or <code>npmin</code> and <code>npmax</code> to constrain the number of allowed changepoints.</p><p>Currently prints results to the terminal (stdout), one line per step of the Markov chain, but a more efficent output format is probably desirable in a future version of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Changepoint.jl#L31-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.cntr-Tuple{AbstractArray}" href="#StatGeochem.cntr-Tuple{AbstractArray}"><code>StatGeochem.cntr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cntr(edges::AbstractArray)</code></pre><p>Given an array of bin edges, return a corresponding vector of bin centers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L772-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.concatenatedatasets-Tuple{AbstractDict, AbstractDict}" href="#StatGeochem.concatenatedatasets-Tuple{AbstractDict, AbstractDict}"><code>StatGeochem.concatenatedatasets</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">concatenatedatasets(d1::AbstractDict, d2::AbstractDict)</code></pre><p>Vertically concatenate two Dict-based datasets, variable-by-variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L518-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.count_unique!-Tuple{Any}" href="#StatGeochem.count_unique!-Tuple{Any}"><code>StatGeochem.count_unique!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">n = count_unique!(A)</code></pre><p>Sort the array <code>A</code> in-place, move unique elements to the front, and return the number of unique elements found. <code>A[1:count_unique!(A)]</code> should return an array equivalent to <code>unique(A)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L747-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.delim_string_function-Tuple{Function, AbstractString, Char, Type}" href="#StatGeochem.delim_string_function-Tuple{Function, AbstractString, Char, Type}"><code>StatGeochem.delim_string_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delim_string_function(f, str, delim, T;
    	merge::Bool=false,</code></pre><p>Parse a delimited string <code>str</code> with delimiter <code>delim</code> into substrings that will then be operated upon by function <code>f</code>. The results of <code>f</code> will be returned in an array with eltype <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.delim_string_parse" href="#StatGeochem.delim_string_parse"><code>StatGeochem.delim_string_parse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delim_string_parse(str, delim, T;
    	merge::Bool=false,
    	undefval=NaN)</code></pre><p>Parse a delimited string <code>str</code> with delimiter <code>delim</code> into values of type <code>T</code> and return the answers as an array with eltype <code>T</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L74-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.delim_string_parse!" href="#StatGeochem.delim_string_parse!"><code>StatGeochem.delim_string_parse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delim_string_parse!(result, str, delim, [T];
    	offset::Integer=0,
    	merge::Bool=false,
    	undefval=NaN)</code></pre><p>Parse a delimited string <code>str</code> with delimiter <code>delim</code> into values of type <code>T</code> and return the answers in a pre-allocated <code>result</code> array provided as input.</p><p>If <code>T</code> is not specified, it the <code>eltype</code> of the <code>result</code> array will be used by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.digitize_plotline-NTuple{4, Any}" href="#StatGeochem.digitize_plotline-NTuple{4, Any}"><code>StatGeochem.digitize_plotline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(x,y) = digitize_plotline(img, line_color, xlims, ylims; atol=0.16)</code></pre><p>Calculate approximate x and y positions for a colored line in an image</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Etc.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.digitize_plotmarkers-NTuple{4, Any}" href="#StatGeochem.digitize_plotmarkers-NTuple{4, Any}"><code>StatGeochem.digitize_plotmarkers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(x,dx,y,dy) = digitize_plotmarkers(img, marker_color, xlims, ylims; atol=0.16)</code></pre><p>Calculate approximate x and y positions and uncertainties for colored markers in an image</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Etc.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.draw_from_distribution!-Tuple{Array{var&quot;#s37&quot;, N} where {var&quot;#s37&quot;&lt;:AbstractFloat, N}, AbstractArray{var&quot;#s32&quot;, N} where {var&quot;#s32&quot;&lt;:AbstractFloat, N}}" href="#StatGeochem.draw_from_distribution!-Tuple{Array{var&quot;#s37&quot;, N} where {var&quot;#s37&quot;&lt;:AbstractFloat, N}, AbstractArray{var&quot;#s32&quot;, N} where {var&quot;#s32&quot;&lt;:AbstractFloat, N}}"><code>StatGeochem.draw_from_distribution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">draw_from_distribution!(dist::AbstractArray{&lt;:AbstractFloat}, x::Array{&lt;:AbstractFloat})</code></pre><p>Fill an existing variable <code>x</code> with random floating point numbers drawn from a continuous probability distribution specified by a vector <code>dist</code> defining the PDF curve thereof.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L1018-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.draw_from_distribution-Tuple{AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:AbstractFloat, N}, Integer}" href="#StatGeochem.draw_from_distribution-Tuple{AbstractArray{var&quot;#s39&quot;, N} where {var&quot;#s39&quot;&lt;:AbstractFloat, N}, Integer}"><code>StatGeochem.draw_from_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">x = draw_from_distribution(dist::AbstractArray{&lt;:AbstractFloat}, n::Integer)</code></pre><p>Draw <code>n</code> random floating point numbers from a continuous probability distribution specified by a vector <code>dist</code> defining the PDF curve thereof.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L1004-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.elementify" href="#StatGeochem.elementify"><code>StatGeochem.elementify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elementify(data::Array, elements::Array=data[1,:];
    	importas=:Dict,
    	standardize::Bool=true,
    	floattype=Float64,
    	skipstart::Integer=1,
    	skipnameless::Bool=true
)</code></pre><p>Convert a flat array <code>data</code> into a dictionary (<code>importas=:Dict</code>) or named tuple (<code>importas=:Tuple</code>) with each column as a variable. Tuples are substantially more efficient, so should be favored where possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L309-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.eustar-NTuple{4, Number}" href="#StatGeochem.eustar-NTuple{4, Number}"><code>StatGeochem.eustar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eustar(Nd::Number, Sm::Number, Gd::Number, Tb::Number)</code></pre><p>Calculate expected europium concentration, Eu*, based on abundance of adjacent rare earths. Full four-element log-linear interpolation, using ionic radii</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.eustar-Tuple{Number, Number}" href="#StatGeochem.eustar-Tuple{Number, Number}"><code>StatGeochem.eustar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eustar(Sm::Number, Gd::Number)</code></pre><p>Calculate expected europium concentration, Eu*, based on abundance of adjacent rare earths. Simple geometric mean interpolation from Sm and Gd alone</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.exportdataset-Tuple{Union{Dict, NamedTuple}, AbstractString, AbstractChar}" href="#StatGeochem.exportdataset-Tuple{Union{Dict, NamedTuple}, AbstractString, AbstractChar}"><code>StatGeochem.exportdataset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exportdataset(dataset, [elements], filepath, delim;
    	floatout::Bool=false,
    	findnumeric::Bool=false,
    	skipnan::Bool=true,
    	digits::Integer,
    	sigdigits::Integer
    	rows=:
)</code></pre><p>Convert a dict or named tuple of vectors into a 2-D array with variables as columns Export a <code>dataset</code> (in the form of either a <code>Dict</code> or a <code>NamedTuple</code>), optionally specifying which <code>elements</code> to export, as a delimited ASCII text file with the name specified by <code>filepath</code> and delimiter <code>delim</code>.</p><p>Possible keyword arguments include:</p><pre><code class="language-none">	digits
	sigdigits</code></pre><p>Specify a number of absolute or significant digits to which to round the printed output. Default is no rounding.</p><pre><code class="language-none">	skipnan</code></pre><p>Leave <code>NaN</code>s as empty cells in the delimited output file. Boolean; <code>true</code> by default.</p><pre><code class="language-none">	floatout</code></pre><p>Force all output to be represented as a floating-point number, or else <code>NaN</code>. Boolean; <code>false</code> by default.</p><pre><code class="language-none">	findnumeric</code></pre><p>Export only numeric columns. Boolean; <code>false</code> by default.</p><pre><code class="language-none">	rows</code></pre><p>specify which rows of the dataset to export. Default <code>:</code> exports all rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L676-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.feoconversion" href="#StatGeochem.feoconversion"><code>StatGeochem.feoconversion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">feoconversion(FeO::Number=NaN, Fe2O3::Number=NaN, FeOT::Number=NaN, Fe2O3T::Number=NaN)</code></pre><p>Compiles data from FeO, Fe2O3, FeOT, and Fe2O3T into  a single FeOT value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.find_grid_inpolygon-NTuple{4, Any}" href="#StatGeochem.find_grid_inpolygon-NTuple{4, Any}"><code>StatGeochem.find_grid_inpolygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(rows, columns) = find_grid_inpolygon(grid_x, grid_y, poly_x, poly_y)</code></pre><p>Find the indexes of grid points that fall within a polygon for a grid with cell centers given by grid<em>x (j-columns of grid) and grid</em>y (i-rows of grid). Returns a list of rows and columns in the polygon</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L284-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.find_tc1_age-Tuple{Number, Number}" href="#StatGeochem.find_tc1_age-Tuple{Number, Number}"><code>StatGeochem.find_tc1_age</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>find_tc1_age(lat::Number,lon::Number)</code></p><p>Return a tuple <code>(age, age_min, age_max)</code> containing the nominal, upper, and lower tc1 age bounds for the 1x1 arc degree grid cell containing <code>lat</code> and <code>lon</code></p><p><code>find_tc1_age(lat::AbstractArray,lon::AbstractArray)</code></p><p>Return a tuple <code>(age, age_min, age_max)</code> where <code>age</code>, <code>age_min</code>, and <code>age_max</code> are arrays containing the nominal, upper and lower tc1 age bounds for each location pair <code>lat[i]</code>, <code>lon[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/resources/tc1/tc1.jl#L90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.find_tc1_crust-Tuple{Number, Number}" href="#StatGeochem.find_tc1_crust-Tuple{Number, Number}"><code>StatGeochem.find_tc1_crust</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>find_tc1_crust(lat::Number,lon::Number)</code></p><p>Find the depth to the 550C isotherm for the 1x1 arc degree grid cell containing <code>lat</code> and <code>lon</code></p><p><code>find_tc1_crust(lat::AbstractArray,lon::AbstractArray)</code></p><p>For each pair of latitudes and longitudes given by lat and lon, find the depth to the 550C isotherm for the 1x1 arc degree grid cell containing <code>lat[i]</code> and <code>lon[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/resources/tc1/tc1.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.find_tc1_lith-Tuple{Number, Number}" href="#StatGeochem.find_tc1_lith-Tuple{Number, Number}"><code>StatGeochem.find_tc1_lith</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>find_tc1_lith(lat::Number,lon::Number)</code></p><p>Find the depth to the 1300C isotherm for the 1x1 arc degree grid cell containing <code>lat</code> and <code>lon</code></p><p><code>find_tc1_lith(lat::AbstractArray,lon::AbstractArray)</code></p><p>For each pair of latitudes and longitudes given by lat and lon, find the depth to the 1300C isotherm for the 1x1 arc degree grid cell containing <code>lat[i]</code> and <code>lon[i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/resources/tc1/tc1.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.findclosest-Tuple{Any, Any}" href="#StatGeochem.findclosest-Tuple{Any, Any}"><code>StatGeochem.findclosest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findclosest(source, target)</code></pre><p>Return the index of the numerically closest value in the indexable collection <code>target</code> for each value in <code>source</code>. If muliple values are equally close, the first one is used</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L876-L883">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.findclosestabove-Tuple{Any, Any}" href="#StatGeochem.findclosestabove-Tuple{Any, Any}"><code>StatGeochem.findclosestabove</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findclosestabove(source, target)</code></pre><p>Return the index of the nearest value of the indexable collection <code>target</code> that is greater than (i.e., &quot;above&quot;) each value in <code>source</code>. If no such values exist in <code>target</code>, returns an index of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L943-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.findclosestbelow-Tuple{Any, Any}" href="#StatGeochem.findclosestbelow-Tuple{Any, Any}"><code>StatGeochem.findclosestbelow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findclosestbelow(source, target)</code></pre><p>Return the index of the nearest value of the indexable collection <code>target</code> that is less than (i.e., &quot;below&quot;) each value in <code>source</code>. If no such target values exist in <code>target</code>, returns an index of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L905-L912">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.findmatches-Tuple{Any, Any}" href="#StatGeochem.findmatches-Tuple{Any, Any}"><code>StatGeochem.findmatches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findmatches(source, target)</code></pre><p>Return the index of the first value in <code>target</code> (if any) that is equal to a given value in <code>source</code> for each value in <code>source</code>; else 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L850-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.findnth-Tuple{AbstractArray{Bool, N} where N, Integer}" href="#StatGeochem.findnth-Tuple{AbstractArray{Bool, N} where N, Integer}"><code>StatGeochem.findnth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findnth(t::AbstractArray{Bool}, n::Integer)</code></pre><p>Return the index of the <code>n</code>th true value of <code>t</code>, else length(<code>t</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L981-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.floatify" href="#StatGeochem.floatify"><code>StatGeochem.floatify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">floatify(x, T::Type=Float64)</code></pre><p>Convert <code>x</code> to a floating-point number (default <code>Float64</code>) by any means necessary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L265-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.gwmean-Tuple{Any, Any}" href="#StatGeochem.gwmean-Tuple{Any, Any}"><code>StatGeochem.gwmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(wx, wσ, mswd) = gwmean(x, σ)</code></pre><p>Geochronologist&#39;s weighted mean, with &quot;MSWD correction&quot; to uncertainty, i.e., wσ is increased by a factor of sqrt(mswd)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.importdataset-Tuple{AbstractString, AbstractChar}" href="#StatGeochem.importdataset-Tuple{AbstractString, AbstractChar}"><code>StatGeochem.importdataset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function importdataset(filepath, delim;
    	importas=:Dict,
    	standardize::Bool=true,
    	floattype=Float64,
    	skipstart::Integer=0,
    	skipnameless::Bool=true,
    	mindefinedcolumns::Integer=0
)</code></pre><p>Import a delimited file specified by <code>filepath</code> with delimiter <code>delim</code> as a dataset in the form of either a <code>Dict</code> or a <code>NamedTuple</code>.</p><p>Possible keyword arguments include:</p><pre><code class="language-none">	importas</code></pre><p>Specify the format of the imported dataset. Options include <code>:Dict</code> and <code>:Tuple</code></p><pre><code class="language-none">	standardize</code></pre><p>Convert columns to uniform type wherever possible. Boolean; <code>true</code> by default.</p><pre><code class="language-none">	floattype</code></pre><p>Preferred floating-point type for numerical data. <code>Float64</code> by default.</p><pre><code class="language-none">	skipstart</code></pre><p>Ignore this many rows at the start of the input file (useful if input file has a header or other text before the column names). <code>0</code> by default.</p><pre><code class="language-none">	skipnameless</code></pre><p>Skip columns with no column name. Boolean; <code>true</code> by default</p><pre><code class="language-none">	mindefinedcolumns</code></pre><p>Skip rows with fewer than this number of delimiters. <code>0</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L613-L647">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.inpctile-Tuple{Any, Any}" href="#StatGeochem.inpctile-Tuple{Any, Any}"><code>StatGeochem.inpctile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inpctile(A, p::Number; dims)</code></pre><p>Return a boolean array that identifies which values of the iterable collection <code>A</code> fall within the central <code>p</code>th percentile, optionally along a dimension specified by <code>dims</code>.</p><p>A valid percentile value must satisfy 0 &lt;= <code>p</code> &lt;= 100.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L110-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.inpolygon-Tuple{Any, Any, Any}" href="#StatGeochem.inpolygon-Tuple{Any, Any, Any}"><code>StatGeochem.inpolygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inpolygon(x,y,point)</code></pre><p>Check if a 2D polygon defined by the arrays <code>x</code>, <code>y</code> contains a given <code>point</code>. Returns boolean (true or false)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.inv_sqrt-Tuple{Float64}" href="#StatGeochem.inv_sqrt-Tuple{Float64}"><code>StatGeochem.inv_sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv_sqrt(x)</code></pre><p>The fast inverse square root of <code>x</code>, in 32 and 64 bit versions. Can be up to 10x faster than base <code>1/sqrt(x)</code>, though with significant loss of precision. The implementations here are good to about 4 ppm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.invweight-Tuple{AbstractArray, AbstractArray, AbstractArray}" href="#StatGeochem.invweight-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>StatGeochem.invweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">k = invweight(lat::AbstractArray, lon::AbstractArray, age::AbstractArray;
    	lp::Number=2,
    	spatialscale=1.8,
    	agescale=38.0
)</code></pre><p>Find the inverse weights <code>k</code> (proportional to spatiotemporal sample density) for a set of geological samples with specified latitude (<code>lat</code>), logitude (<code>lon</code>), and <code>age</code> (of crystallization, deposition, etc.).</p><p>The default <code>spatialscale</code> and <code>agescale</code> are taken from Keller and Schoene 2012. However, alternative scalings can be supplied. If an array is supplied for either <code>spatialscale</code>, <code>agescale</code>, or both, a 3-d matrix of <code>k</code> values will be returned, with dimensions length(<code>spatialscale</code>)<em>length(<code>agescale</code>)</em>nrows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L844-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.invweight-Tuple{AbstractArray, Number}" href="#StatGeochem.invweight-Tuple{AbstractArray, Number}"><code>StatGeochem.invweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">k = invweight(nums::AbstractArray, scale::Number; lp=2)</code></pre><p>Find the inverse weights for a single array <code>nums</code> for a given <code>scale</code>, and exponent <code>lp</code> (default lp = 2).</p><p>Returns an array k where k[i] is the &quot;inverse weight&quot; for element i of the input array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L949-L959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.invweight_age-Tuple{AbstractArray}" href="#StatGeochem.invweight_age-Tuple{AbstractArray}"><code>StatGeochem.invweight_age</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">k = invweight_age(age::AbstractArray; lp::Number=2, agescale::Number=38.0)</code></pre><p>Find the inverse weights <code>k</code> (proportional to temporal sample density) for a set of geological samples with specified <code>age</code> (of crystallization, deposition, etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L977-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.invweight_location-Tuple{AbstractArray, AbstractArray}" href="#StatGeochem.invweight_location-Tuple{AbstractArray, AbstractArray}"><code>StatGeochem.invweight_location</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">k = invweight_location(lat::AbstractArray, lon::AbstractArray;
    	lp::Number=2,
    	spatialscale::Number=1.8
)</code></pre><p>Find the inverse weights <code>k</code> (proportional to spatial sample density) for a set of geological samples with specified latitude (<code>lat</code>), and logitude (<code>lon</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L909-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.melts_clean_modes-Tuple{String}" href="#StatGeochem.melts_clean_modes-Tuple{String}"><code>StatGeochem.melts_clean_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">melts_clean_modes(scratchdir::String; index=1)</code></pre><p>Read and parse / clean-up modal phase proportions from specified MELTS run directory Returns an elementified dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L383-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.melts_configure" href="#StatGeochem.melts_configure"><code>StatGeochem.melts_configure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">melts_configure(meltspath::String, scratchdir::String, composition::Array{Float64},
    	elements::Array,
    	T_range::Array=[1400, 600],
    	P_range::Array=[10000,10000];)</code></pre><p>Configure and run a MELTS simulation using alphaMELTS. Optional keyword arguments and defaults:</p><p><code>batchstring::String=&quot;1 sc.melts 10 1 3 1 liquid 1 1.0 0 10 0 4 0 &quot;</code></p><p><code>dT = -10</code></p><p><code>dP = 0</code></p><p><code>index = 1</code></p><p><code>version = &quot;pMELTS&quot;</code></p><p><code>mode = &quot;isobaric&quot;</code></p><p><code>fo2path = &quot;FMQ&quot;</code> Oxygen fugacity buffer to follow, e.g., <code>FMQ</code> or <code>NNO+1</code></p><p><code>fractionatesolids::Bool = false</code> Fractionate all solids</p><p><code>suppress::Array{String} = []</code> Supress individual phases (specify as strings in array, i.e. <code>[&quot;leucite&quot;]</code>)</p><p><code>verbose::Bool = true</code> Print verbose MELTS output to terminal (else, write it to <code>melts.log</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L150-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.melts_query-Tuple{String}" href="#StatGeochem.melts_query-Tuple{String}"><code>StatGeochem.melts_query</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">melts_query_modes(scratchdir::String; index=1)</code></pre><p>Read all phase proportions from <code>Phase_main_tbl.txt</code> in specified MELTS run directory Returns an elementified dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L334-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.melts_query_liquid-Tuple{String}" href="#StatGeochem.melts_query_liquid-Tuple{String}"><code>StatGeochem.melts_query_liquid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">melts_query_liquid(scratchdir::String; index=1)</code></pre><p>Read liquid composition from <code>Liquid_comp_tbl.txt</code> in specified MELTS run directory Returns an elementified dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L469-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.melts_query_modes-Tuple{String}" href="#StatGeochem.melts_query_modes-Tuple{String}"><code>StatGeochem.melts_query_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">melts_query_modes(scratchdir::String; index=1)</code></pre><p>Read modal phase proportions from <code>Phase_mass_tbl.txt</code> in specified MELTS run Returns an elementified dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.melts_query_solid-Tuple{String}" href="#StatGeochem.melts_query_solid-Tuple{String}"><code>StatGeochem.melts_query_solid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">melts_query_solid(scratchdir::String; index=1)</code></pre><p>Read solid composition from <code>Solid_comp_tbl.txt</code> in specified MELTS run directory Returns an elementified dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L493-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.midpointintegrate-Tuple{AbstractRange, AbstractArray}" href="#StatGeochem.midpointintegrate-Tuple{AbstractRange, AbstractArray}"><code>StatGeochem.midpointintegrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">midpointintegrate(bincenters, values)</code></pre><p>Add up the area under a curve with y positions specified by a vector of <code>values</code> and x positions specfied by a vector of <code>bincenters</code> using midpoint integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L1077-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.movmean-Tuple{AbstractVector{T} where T, Number}" href="#StatGeochem.movmean-Tuple{AbstractVector{T} where T, Number}"><code>StatGeochem.movmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">movmean(x::AbstractVecOrMat, n::Number)</code></pre><p>Simple moving average of <code>x</code> in 1 or 2 dimensions, spanning <code>n</code> bins (or n*n in 2D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L815-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanaad-Tuple{Any}" href="#StatGeochem.nanaad-Tuple{Any}"><code>StatGeochem.nanaad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanaad(A; dims)</code></pre><p>Mean (average) absolute deviation from the mean, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>. Note that for a Normal distribution, sigma = 1.253 * AAD</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L708-L715">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanadd!-Tuple{Array, Union{Tuple, AbstractArray}}" href="#StatGeochem.nanadd!-Tuple{Array, Union{Tuple, AbstractArray}}"><code>StatGeochem.nanadd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanadd!(A::Array, B)</code></pre><p>Add the non-NaN elements of <code>B</code> to <code>A</code>, treating NaNs as zeros</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanadd-Tuple{Any, Any}" href="#StatGeochem.nanadd-Tuple{Any, Any}"><code>StatGeochem.nanadd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanadd(a::Number, b::Number)</code></pre><p>Add <code>a</code> to <code>b</code>, returning NaN only if both are NaN</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanadd-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}" href="#StatGeochem.nanadd-Tuple{Union{Tuple, AbstractArray}, Union{Tuple, AbstractArray}}"><code>StatGeochem.nanadd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanadd(A::AbstractArray, B::AbstractArray)</code></pre><p>Add the non-NaN elements of A and B, treating NaNs as zeros</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanextrema-Tuple{Any}" href="#StatGeochem.nanextrema-Tuple{Any}"><code>StatGeochem.nanextrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanextrema(A; dims)</code></pre><p>Find the extrema (maximum &amp; minimum) of an indexable collection <code>A</code>, ignoring NaNs, optionally along a dimension specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmad-Tuple{Any}" href="#StatGeochem.nanmad-Tuple{Any}"><code>StatGeochem.nanmad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmad(A; dims)</code></pre><p>Median absolute deviation from the median, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>. Note that for a Normal distribution, sigma = 1.4826 * MAD</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L675-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmask!-Tuple{Any, Any}" href="#StatGeochem.nanmask!-Tuple{Any, Any}"><code>StatGeochem.nanmask!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmask!(mask, A)</code></pre><p>Fill a Boolean mask of dimensions <code>size(A)</code> that is false wherever <code>A</code> is <code>NaN</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmask-Tuple{Any}" href="#StatGeochem.nanmask-Tuple{Any}"><code>StatGeochem.nanmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmask(A)</code></pre><p>Create a Boolean mask of dimensions <code>size(A)</code> that is false wherever <code>A</code> is <code>NaN</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmax-Tuple{Any, Any}" href="#StatGeochem.nanmax-Tuple{Any, Any}"><code>StatGeochem.nanmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmax(a,b)</code></pre><p>As <code>max(a,b)</code>, but if either argument is <code>NaN</code>, return the other one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmaximum-Tuple{Any}" href="#StatGeochem.nanmaximum-Tuple{Any}"><code>StatGeochem.nanmaximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmaximum(A; dims)</code></pre><p>Find the largest non-NaN value of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L229-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmean!-Tuple{AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}" href="#StatGeochem.nanmean!-Tuple{AbstractVecOrMat{T} where T, AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmean!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmean!(MU, [N], x, y, [w], xmin::Number, xmax::Number, nbins::Integer)</code></pre><p>Ignoring NaNs, fill the array <code>MU</code> with the means (and optionally <code>N</code> with the counts) of non-NAN <code>y</code> values that fall into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, aligned with bin edges as <code>xmin</code>:(<code>xmax</code>-<code>xmin</code>)/<code>nbins</code>:<code>xmax</code></p><p>If an optional array of weights [<code>w</code>] is specified, then <code>N</code> is required, and will be filled with the sum of weights for each bin.</p><p>The array of <code>x</code> data should given as a one-dimensional array (any subtype of AbstractVector) and <code>y</code> as either a 1-d or 2-d array (any subtype of AbstractVecOrMat).</p><p>The output arrays <code>MU</code> and <code>N</code> must be the same size, and must have the same number of columns as <code>y</code>; if <code>y</code> is a 2-d array (matrix), then each column of <code>y</code> will be treated as a separate variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L362-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}" href="#StatGeochem.nanmean-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmean(x, y, [w], xmin::Number, xmax::Number, nbins::Integer)</code></pre><p>Ignoring NaNs, calculate the mean (optionally weighted) of <code>y</code> values that fall into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, aligned with bin edges as <code>xmin</code>:(<code>xmax</code>-<code>xmin</code>)/<code>nbins</code>:<code>xmax</code></p><p>The array of <code>x</code> data should given as a one-dimensional array (any subtype of AbstractVector) and <code>y</code> as either a 1-d or 2-d array (any subtype of AbstractVecOrMat). If <code>y</code> is a 2-d array, then each column of <code>y</code> will be treated as a separate variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L336-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmean-Tuple{Any}" href="#StatGeochem.nanmean-Tuple{Any}"><code>StatGeochem.nanmean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmean(A, [W]; dims)</code></pre><p>Ignoring NaNs, calculate the mean (optionally weighted) of an indexable collection <code>A</code>, optionally along dimensions specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L268-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmedian!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Number, Number, Integer}" href="#StatGeochem.nanmedian!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmedian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmedian!(M::AbstractVecOrMat, x::AbstractVector, y::AbstractVecOrMat, xmin::Number, xmax::Number, nbins::Integer)</code></pre><p>Fill the array <code>M</code> with the medians of non-NaN <code>y</code> values that fall into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, aligned with bin edges as <code>xmin</code>:(<code>xmax</code>-<code>xmin</code>)/<code>nbins</code>:<code>xmax</code></p><p>If <code>y</code> is a 2-d array (matrix), each column will be treated as a separate variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L617-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmedian-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}" href="#StatGeochem.nanmedian-Tuple{AbstractVector{T} where T, AbstractVecOrMat{T} where T, Number, Number, Integer}"><code>StatGeochem.nanmedian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmedian(x::AbstractVector, y::AbstractVecOrMat, xmin::Number, xmax::Number, nbins::Integer)</code></pre><p>Calculate the median, ignoring NaNs, of y values that fall into each of <code>nbins</code> equally spaced <code>x</code> bins between <code>xmin</code> and <code>xmax</code>, aligned with bin edges as <code>xmin</code>:(<code>xmax</code>-<code>xmin</code>)/<code>nbins</code>:<code>xmax</code></p><p>If <code>y</code> is a 2-d array (matrix), each column will be treated as a separate variable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L601-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmedian-Tuple{Any}" href="#StatGeochem.nanmedian-Tuple{Any}"><code>StatGeochem.nanmedian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmedian(A; dims)</code></pre><p>Calculate the median, ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L564-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanmin-Tuple{Any, Any}" href="#StatGeochem.nanmin-Tuple{Any, Any}"><code>StatGeochem.nanmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanmin(a,b)</code></pre><p>As <code>min(a,b)</code>, but if either argument is <code>NaN</code>, return the other one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanminimum-Tuple{Any}" href="#StatGeochem.nanminimum-Tuple{Any}"><code>StatGeochem.nanminimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanminimum(A; dims)</code></pre><p>As <code>minimum</code> but ignoring <code>NaN</code>s: Find the smallest non-<code>NaN</code> value of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanrange-Tuple{Any}" href="#StatGeochem.nanrange-Tuple{Any}"><code>StatGeochem.nanrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanrange(A; dims)</code></pre><p>Calculate the range (maximum - minimum) of an indexable collection <code>A</code>, ignoring NaNs, optionally along a dimension specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L257-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nanstd-Tuple{Any}" href="#StatGeochem.nanstd-Tuple{Any}"><code>StatGeochem.nanstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nanstd(A, [W]; dims)</code></pre><p>Calculate the standard deviation (optionaly weighted), ignoring NaNs, of an indexable collection <code>A</code>, optionally along a dimension specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L477-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nansum-Tuple{Any}" href="#StatGeochem.nansum-Tuple{Any}"><code>StatGeochem.nansum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nansum(A; dims)</code></pre><p>Calculate the sum of an indexable collection <code>A</code>, ignoring NaNs, optionally along dimensions specified by <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nearest-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Integer" href="#StatGeochem.nearest-Union{Tuple{T}, Tuple{Type{T}, Any}} where T&lt;:Integer"><code>StatGeochem.nearest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearest(T, x)</code></pre><p>Convert <code>x</code> to the nearest representable value in type T, rounding if inexact</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.nonnumeric-Tuple{Any}" href="#StatGeochem.nonnumeric-Tuple{Any}"><code>StatGeochem.nonnumeric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nonnumeric(x)</code></pre><p>Return true for if <code>x</code> is not missing but cannot be parsed as a number</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L246-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.norm_quantile-Tuple{Any}" href="#StatGeochem.norm_quantile-Tuple{Any}"><code>StatGeochem.norm_quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_quantile(F::Number)</code></pre><p>How far away from the mean (in units of sigma) should we expect proportion F of the samples to fall in a standard Gaussian (Normal[0,1]) distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.norm_width-Tuple{Any}" href="#StatGeochem.norm_width-Tuple{Any}"><code>StatGeochem.norm_width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_width(N::Number)</code></pre><p>How dispersed (in units of sigma) should we expect a sample of N numbers drawn from a standard Gaussian (Normal[0,1]) distribution to be?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.normcdf!-Tuple{Array, Number, Number, AbstractArray}" href="#StatGeochem.normcdf!-Tuple{Array, Number, Number, AbstractArray}"><code>StatGeochem.normcdf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normcdf!(result,mu,sigma,x)</code></pre><p>In-place version of <code>normcdf</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.normcdf-Tuple{Any, Any, Any}" href="#StatGeochem.normcdf-Tuple{Any, Any, Any}"><code>StatGeochem.normcdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normcdf(mu,sigma,x)</code></pre><p>Cumulative density function of the Normal (Gaussian) distribution</p><p><span>$1/2 + erf(rac{x-μ}{σ√2})/2$</span></p><p>with mean <code>mu</code> and standard deviation <code>sigma</code>, evaluated at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.normpdf-Tuple{Any, Any, Any}" href="#StatGeochem.normpdf-Tuple{Any, Any, Any}"><code>StatGeochem.normpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normpdf(mu,sigma,x)</code></pre><p>Probability density function of the Normal (Gaussian) distribution</p><p><span>$ℯ^{-(x-μ)^2 / (2σ^2)} / σ√2π$</span></p><p>with mean <code>mu</code> and standard deviation <code>sigma</code>, evaluated at <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L55-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.normpdf_ll-Tuple{Any, Any, Any}" href="#StatGeochem.normpdf_ll-Tuple{Any, Any, Any}"><code>StatGeochem.normpdf_ll</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normpdf_ll(mu, sigma, x)</code></pre><p>Fast log likelihood corresponding to a Normal (Gaussian) distribution with mean <code>mu</code> and standard deviation <code>sigma</code>, evaluated at <code>x</code>.</p><p>If <code>x</code>, [<code>mu</code>, and <code>sigma</code>] are given as arrays, the sum of the log likelihood over all <code>x</code> will be returned.</p><p>See also <code>normpdf</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.normproduct-NTuple{4, Any}" href="#StatGeochem.normproduct-NTuple{4, Any}"><code>StatGeochem.normproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normproduct(μ1, σ1, μ2, σ2)</code></pre><p>The integral of the product of two normal distributions N[μ1,σ1] * N[μ2,σ2]. This is itself just another Normal distribution! Specifically, one with variance σ1^2 + σ2^2, evaluated at distance |μ1-μ2| from the mean</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L170-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.normproduct_ll-NTuple{4, Any}" href="#StatGeochem.normproduct_ll-NTuple{4, Any}"><code>StatGeochem.normproduct_ll</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normproduct_ll(μ1, σ1, μ2, σ2)</code></pre><p>Log likelihood corresponding to the integral of N[μ1,σ1] * N[μ2,σ2] As <code>normproduct</code>, but using the fast log likelihood of a Normal distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.oxideconversion!-Tuple{Dict}" href="#StatGeochem.oxideconversion!-Tuple{Dict}"><code>StatGeochem.oxideconversion!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dataset = oxideconversion!(dataset::Dict; unitratio::Number=10000)</code></pre><p>Convert major elements (Ti, Al, etc.) into corresponding oxides (TiO2, Al2O3, ...) in place.</p><p>If metals are as PPM, set unitratio=10000 (default); if metals are as wt%, set unitratio = 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.oxideconversion-Tuple{Dict}" href="#StatGeochem.oxideconversion-Tuple{Dict}"><code>StatGeochem.oxideconversion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dataset = oxideconversion(dataset::Dict; unitratio::Number=10000)</code></pre><p>Convert major elements (Ti, Al, etc.) into corresponding oxides (TiO2, Al2O3, ...).</p><p>If metals are as PPM, set unitratio=10000 (default); if metals are as wt%, set unitratio = 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L74-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.parsedlm" href="#StatGeochem.parsedlm"><code>StatGeochem.parsedlm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parsedlm(str::AbstractString, delimiter::Char, T::Type=Float64; rowdelimiter::Char=&#39;\n&#39;)</code></pre><p>Parse a string delimited by both row and column into a single (2-D) matrix. Default column delimiter is newline. Similar to <code>readdlm</code>, but operating on a string instead of a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L166-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.pctile-Tuple{Any, Any}" href="#StatGeochem.pctile-Tuple{Any, Any}"><code>StatGeochem.pctile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctile(A, p; dims)</code></pre><p>Find the <code>p</code>th percentile of an indexable collection <code>A</code>, ignoring NaNs, optionally along a dimension specified by <code>dims</code>.</p><p>A valid percentile value must satisfy 0 &lt;= <code>p</code> &lt;= 100.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L70-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_configure_geotherm" href="#StatGeochem.perplex_configure_geotherm"><code>StatGeochem.perplex_configure_geotherm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perplex_configure_geotherm(perplexdir::String, scratchdir::String, composition::Array{&lt;:Number},
    	elements::String=[&quot;SIO2&quot;,&quot;TIO2&quot;,&quot;AL2O3&quot;,&quot;FEO&quot;,&quot;MGO&quot;,&quot;CAO&quot;,&quot;NA2O&quot;,&quot;K2O&quot;,&quot;H2O&quot;],
    	P_range::Array{&lt;:Number}=[280,28000], T_surf::Number=273.15, geotherm::Number=0.1;
    	dataset::String=&quot;hp02ver.dat&quot;,
    	index::Integer=1,
    	npoints::Integer=100,
    	solution_phases::String=&quot;O(HP)\nOpx(HP)\nOmph(GHP)\nGt(HP)\noAmph(DP)\ncAmph(DP)\nT\nB\nChl(HP)\nBio(TCC)\nMica(CF)\nCtd(HP)\nIlHm(A)\nSp(HP)\nSapp(HP)\nSt(HP)\nfeldspar_B\nDo(HP)\nF\n&quot;,
    	excludes::String=&quot;ts\nparg\ngl\nged\nfanth\ng\n&quot;,
    	mode_basis::String=&quot;vol&quot;,  #[&quot;vol&quot;, &quot;wt&quot;, &quot;mol&quot;]
    	composition_basis::String=&quot;wt&quot;,  #[&quot;vol&quot;, &quot;wt&quot;, &quot;mol&quot;]
    	fluid_eos::Integer=5)</code></pre><p>Set up a PerpleX calculation for a single bulk composition along a specified geothermal gradient and pressure (depth) range. P specified in bar and T_surf in Kelvin, with geothermal gradient in units of Kelvin/bar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L537-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_configure_isobar" href="#StatGeochem.perplex_configure_isobar"><code>StatGeochem.perplex_configure_isobar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perplex_configure_isobar(perplexdir::String, scratchdir::String, composition::Array{&lt;:Number},
    	elements::String=[&quot;SIO2&quot;,&quot;TIO2&quot;,&quot;AL2O3&quot;,&quot;FEO&quot;,&quot;MGO&quot;,&quot;CAO&quot;,&quot;NA2O&quot;,&quot;K2O&quot;,&quot;H2O&quot;]
    	P::Number=10000, T::Array{&lt;:Number}=[500+273.15, 1500+273.15];
    	dataset::String=&quot;hp11ver.dat&quot;,
    	index::Integer=1,
    	npoints::Integer=100,
    	solution_phases::String=&quot;O(HP)\nOpx(HP)\nOmph(GHP)\nGt(HP)\noAmph(DP)\ncAmph(DP)\nT\nB\nChl(HP)\nBio(TCC)\nMica(CF)\nCtd(HP)\nIlHm(A)\nSp(HP)\nSapp(HP)\nSt(HP)\nfeldspar_B\nDo(HP)\nF\n&quot;,
    	excludes::String=&quot;ts\nparg\ngl\nged\nfanth\ng\n&quot;,
    	mode_basis::String=&quot;vol&quot;,  #[&quot;vol&quot;, &quot;wt&quot;, &quot;mol&quot;]
    	composition_basis::String=&quot;wt&quot;,  #[&quot;vol&quot;, &quot;wt&quot;, &quot;mol&quot;]
    	fluid_eos::Integer=5)</code></pre><p>Set up a PerpleX calculation for a single bulk composition along a specified isobaric temperature gradient. P specified in bar and T_range in Kelvin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L625-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_configure_pseudosection" href="#StatGeochem.perplex_configure_pseudosection"><code>StatGeochem.perplex_configure_pseudosection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">perplex_configure_pseudosection(perplexdir::String, scratchdir::String, composition::Array{&lt;:Number},
    	elements::Array{String}=[&quot;SIO2&quot;,&quot;TIO2&quot;,&quot;AL2O3&quot;,&quot;FEO&quot;,&quot;MGO&quot;,&quot;CAO&quot;,&quot;NA2O&quot;,&quot;K2O&quot;,&quot;H2O&quot;],
    	P::Array{&lt;:Number}=[280, 28000], T::Array{&lt;:Number}=[273.15, 1500+273.15];
    	dataset::String=&quot;hp11ver.dat&quot;,
    	index::Integer=1,
    	xnodes::Integer=42,
    	ynodes::Integer=42,
    	solution_phases::String=&quot;O(HP)\nOpx(HP)\nOmph(GHP)\nGt(HP)\noAmph(DP)\ncAmph(DP)\nT\nB\nChl(HP)\nBio(TCC)\nMica(CF)\nCtd(HP)\nIlHm(A)\nSp(HP)\nSapp(HP)\nSt(HP)\nfeldspar_B\nDo(HP)\nF\n&quot;,
    	excludes::String=&quot;ts\nparg\ngl\nged\nfanth\ng\n&quot;,
    	mode_basis::String=&quot;vol&quot;, #[&quot;vol&quot;, &quot;wt&quot;, &quot;mol&quot;]
    	composition_basis::String=&quot;wt&quot;, #[&quot;wt&quot;, &quot;mol&quot;]
    	fluid_eos::Number=5)</code></pre><p>Set up a PerpleX calculation for a single bulk composition across an entire 2d P-T space. P specified in bar and T in Kelvin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L703-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_modes-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}" href="#StatGeochem.perplex_query_modes-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_modes(perplexdir::String, scratchdir::String, P::Array{&lt;:Number}, T::Array{&lt;:Number};
    	index::Integer=1, npoints::Integer=200, include_fluid=&quot;y&quot;)</code></pre><p>Query modal mineralogy (mass proportions) along a specified P-T path using a pre-computed pseudosection. Results are returned as a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1191-L1199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_modes-Tuple{String, String}" href="#StatGeochem.perplex_query_modes-Tuple{String, String}"><code>StatGeochem.perplex_query_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_modes(perplexdir::String, scratchdir::String;
    	dof::Integer=1, index::Integer=1, include_fluid=&quot;y&quot;)</code></pre><p>Query modal mineralogy (mass proportions) along a previously configured 1-d path (dof=1, isobar or geotherm) or 2-d grid / pseudosection (dof=2). Results are returned as a dictionary.</p><p>Currently returns vol %</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1134-L1145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_phase-Tuple{String, String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}" href="#StatGeochem.perplex_query_phase-Tuple{String, String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_phase(perplexdir::String, scratchdir::String, phase::String, P::Array{&lt;:Number}, T::Array{&lt;:Number};
    	index::Integer=1, npoints::Integer=200, include_fluid=&quot;y&quot;, clean_units::Bool=true)</code></pre><p>Query all perplex-calculated properties for a specified phase (e.g. &quot;Melt(G)&quot;) along a specified P-T path using a pre-computed pseudosection. Results are returned as a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1062-L1071">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_phase-Tuple{String, String, String}" href="#StatGeochem.perplex_query_phase-Tuple{String, String, String}"><code>StatGeochem.perplex_query_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_phase(perplexdir::String, scratchdir::String, phase::String;
    	dof::Integer=1, index::Integer=1, include_fluid=&quot;y&quot;, clean_units::Bool=true)</code></pre><p>Query all perplex-calculated properties for a specified phase (e.g. &quot;Melt(G)&quot;) along a previously configured 1-d path (dof=1, isobar or geotherm) or 2-d grid / pseudosection (dof=2). Results are returned as a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L985-L994">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_point-Tuple{String, String, Number, Number}" href="#StatGeochem.perplex_query_point-Tuple{String, String, Number, Number}"><code>StatGeochem.perplex_query_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_point(perplexdir::String, scratchdir::String, P::Number, T::Number; index::Integer=1)</code></pre><p>Query perplex results at a single P,T point in a pseudosection. Results are returned as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L828-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_point-Tuple{String, String, Number}" href="#StatGeochem.perplex_query_point-Tuple{String, String, Number}"><code>StatGeochem.perplex_query_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_point(perplexdir::String, scratchdir::String, indvar::Number; index::Integer=1)</code></pre><p>Query perplex results at a single temperature on an isobar or single pressure on a geotherm. Results are returned as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L785-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_seismic-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}" href="#StatGeochem.perplex_query_seismic-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_seismic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_seismic(perplexdir::String, scratchdir::String, P::Array{&lt;:Number}, T::Array{&lt;:Number};
    	index::Integer=1, npoints::Integer=200, include_fluid=&quot;n&quot;)</code></pre><p>Query perplex seismic results along a specified P-T path using a pre-computed pseudosection. Results are returned as a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L935-L943">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_seismic-Tuple{String, String}" href="#StatGeochem.perplex_query_seismic-Tuple{String, String}"><code>StatGeochem.perplex_query_seismic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_seismic(perplexdir::String, scratchdir::String;
    	dof::Integer=1, index::Integer=1, include_fluid=&quot;n&quot;)</code></pre><p>Query perplex seismic results along a previously configured 1-d path (dof=1, isobar or geotherm) or 2-d grid / pseudosection (dof=2). Results are returned as a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L881-L890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_system-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}" href="#StatGeochem.perplex_query_system-Tuple{String, String, Array{var&quot;#s184&quot;, N} where {var&quot;#s184&quot;&lt;:Number, N}, Array{var&quot;#s183&quot;, N} where {var&quot;#s183&quot;&lt;:Number, N}}"><code>StatGeochem.perplex_query_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function perplex_query_system(perplexdir::String, scratchdir::String, P::Array{&lt;:Number}, T::Array{&lt;:Number};
    	index::Integer=1, npoints::Integer=200, include_fluid=&quot;y&quot;,clean_units::Bool=true)</code></pre><p>Query all perplex-calculated properties for the system (with or without fluid) along a specified P-T path using a pre-computed pseudosection. Results are returned as a dictionary. Set include_fluid=&quot;n&quot; to return solid+melt only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1308-L1317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.perplex_query_system-Tuple{String, String}" href="#StatGeochem.perplex_query_system-Tuple{String, String}"><code>StatGeochem.perplex_query_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perplex_query_system(perplexdir::String, scratchdir::String;
    	index::Integer=1, include_fluid=&quot;y&quot;, clean_units::Bool=true)</code></pre><p>?</p><p>Query all perplex-calculated properties for the system (with or without fluid) along a previously configured 1-d path (dof=1, isobar or geotherm) or 2-d grid / pseudosection (dof=2). Results are returned as a dictionary. Set include_fluid=&quot;n&quot; to return solid+melt only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Geochemistry.jl#L1240-L1250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.plausiblynumeric-Tuple{Any}" href="#StatGeochem.plausiblynumeric-Tuple{Any}"><code>StatGeochem.plausiblynumeric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plausiblynumeric(x)</code></pre><p>Return <code>true</code> if <code>x</code> can be parsed as a number, else <code>false</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.randsample" href="#StatGeochem.randsample"><code>StatGeochem.randsample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randsample(data::Array, nrows, [p])</code></pre><p>Bootstrap resample (without uncertainty) a <code>data</code> array to length <code>nrows</code>. Optionally provide weights <code>p</code> either as a vector (one-weight-per-sample) or scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L307-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.randsample" href="#StatGeochem.randsample"><code>StatGeochem.randsample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randsample(dataset::Dict, nrows, [elements], [p])</code></pre><p>Bootstrap resample (without uncertainty) a <code>dataset</code> dict to length <code>nrows</code>. Optionally provide weights <code>p</code> either as a vector (one-weight-per-sample) or scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Resampling.jl#L322-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.renormalize!" href="#StatGeochem.renormalize!"><code>StatGeochem.renormalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">renormalize!(dataset, [elements]; total=1.0)</code></pre><p>Normalize in-place a (i.e., compositional) <code>dataset</code> defined by a <code>Dict</code> or <code>NamedTuple</code> of one-dimensional numerical arrays, such that all the <code>elements</code> (i.e., variables – by default all keys in the datset) sum to a given <code>total</code> (by default, <code>1.0</code>).</p><p>Note that the arrays representing each element or variable are assumed to be of uniform length</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L583-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.renormalize!-Tuple{AbstractArray}" href="#StatGeochem.renormalize!-Tuple{AbstractArray}"><code>StatGeochem.renormalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">renormalize!(A::AbstractArray; dim, total=1.0)</code></pre><p>Normalize an array <code>A</code> in place such that it sums to <code>total</code>. Optionally may specify a dimension <code>dim</code> along which to normalize.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L572-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.standardize!-Tuple{Array{var&quot;#s32&quot;, N} where {var&quot;#s32&quot;&lt;:AbstractFloat, N}}" href="#StatGeochem.standardize!-Tuple{Array{var&quot;#s32&quot;, N} where {var&quot;#s32&quot;&lt;:AbstractFloat, N}}"><code>StatGeochem.standardize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">standardize!(A::Array{&lt;:AbstractFloat}; dims)</code></pre><p>Rescale <code>A</code> to unit variance and zero mean</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L723-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.standardize-Tuple{AbstractArray}" href="#StatGeochem.standardize-Tuple{AbstractArray}"><code>StatGeochem.standardize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">standardize(A; dims)</code></pre><p>Rescale a copy of <code>A</code> to unit variance and zero mean</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L737-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.system-Tuple{AbstractString}" href="#StatGeochem.system-Tuple{AbstractString}"><code>StatGeochem.system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">system(cmdstr::AbstractString)</code></pre><p>Direct access to the command line through C&#39;s <code>system</code> function – without stripping/sanitizing special characters,  in contrast to Julia&#39;s safer <code>run()</code> function. This allows pipelining, etc. in shell commands. Returns 0 on success.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/System.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.trapz-Tuple{AbstractRange, AbstractArray}" href="#StatGeochem.trapz-Tuple{AbstractRange, AbstractArray}"><code>StatGeochem.trapz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trapz(edges, values)</code></pre><p>Add up the area under a curve with y positions specified by a vector of <code>values</code> and x positions specfied by a vector of <code>edges</code> using trapezoidal integration. Bins need not be evenly spaced, though it helps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L1052-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.unelementify" href="#StatGeochem.unelementify"><code>StatGeochem.unelementify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unelementify(dataset, elements;
    	floatout::Bool=false,
    	floattype=Float64,
    	findnumeric::Bool=false,
    	skipnan::Bool=false,
    	rows=:
)</code></pre><p>Convert a dict or named tuple of vectors into a 2-D array with variables as columns</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Import.jl#L400-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.yorkfit-NTuple{4, Any}" href="#StatGeochem.yorkfit-NTuple{4, Any}"><code>StatGeochem.yorkfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yorkfit(x, σx, y, σy)</code></pre><p>Uses the York (1968) least-squares fit to calculate <code>a</code>, <code>b</code>, and uncertanties <code>σa</code>, <code>σb</code> for the equation <code>y = a + bx</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/Math.jl#L455-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatGeochem.zeronan!-Tuple{Array}" href="#StatGeochem.zeronan!-Tuple{Array}"><code>StatGeochem.zeronan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zeronan!(A)</code></pre><p>Replace all <code>NaN</code>s in A with zeros of the same type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StatGeochem.jl/blob/5c5e43615ba35b28c10aeba99e0c603d2c308083/src/utilities/ArrayStats.jl#L28-L33">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 5 June 2021 04:23">Saturday 5 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
